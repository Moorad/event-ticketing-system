import NextAuth from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import { z } from "zod";
import { PrismaClient } from "@prisma/client";
import bcrypt from "bcrypt";

const prisma = new PrismaClient();
const saltRounds = 10;

import type { AuthOptions } from "next-auth";

const authConfig = {
	pages: {
		signIn: "/auth/sign-in",
	},
	// callbacks: {
	// 	authorized({ auth, req }) {
	// 		// "!!" converts any falsy value into false e.g. null, undefined, NaN -> false
	// 		const isLoggedIn = !!auth?.user;

	// 		if (isLoggedIn) {
	// 			return true;
	// 		}

	// 		return false;
	// 	},
	// },
	providers: [
		CredentialsProvider({
			name: "credentials",
			credentials: {
				username: {
					label: "Username",
					type: "text",
					placeholder: "jsmith",
				},
				password: { label: "Password", type: "password" },
			},
			async authorize(credentials, req) {
				// validation
				const validCredentials = z
					.object({
						email: z.string().email(),
						password: z.string().min(8),
					})
					.safeParse(credentials);

				if (!validCredentials.success) {
					return null;
				}

				const { email, password } = validCredentials.data;

				const account = await prisma.account.findUnique({
					where: {
						email: email,
					},
				});

				// Account not found
				if (account == null) {
					return null;
				}

				const pw = await bcrypt.hash(password, saltRounds);
				console.log(pw);

				const passwordsMatch = await bcrypt.compare(
					password,
					account.password
				);

				// Passwords do not match
				if (!passwordsMatch) {
					return null;
				}

				return account;
			},
		}),
	],
} satisfies AuthOptions;

export default NextAuth(authConfig);
